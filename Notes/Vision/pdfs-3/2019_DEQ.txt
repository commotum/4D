                                                                    Deep Equilibrium Models


                                                      Shaojie Bai                          J. Zico Kolter                 Vladlen Koltun
                                               Carnegie Mellon University            Carnegie Mellon University              Intel Labs
                                                                                        Bosch Center for AI
arXiv:1909.01377v2 [cs.LG] 28 Oct 2019




                                                                                       Abstract
                                                  We present a new approach to modeling sequential data: the deep equilibrium
                                                  model (DEQ). Motivated by an observation that the hidden layers of many existing
                                                  deep sequence models converge towards some fixed point, we propose the DEQ
                                                  approach that directly finds these equilibrium points via root-finding. Such a
                                                  method is equivalent to running an infinite depth (weight-tied) feedforward network,
                                                  but has the notable advantage that we can analytically backpropagate through the
                                                  equilibrium point using implicit differentiation. Using this approach, training
                                                  and prediction in these networks require only constant memory, regardless of the
                                                  effective “depth” of the network. We demonstrate how DEQs can be applied to
                                                  two state-of-the-art deep sequence models: self-attention transformers and trellis
                                                  networks. On large-scale language modeling tasks, such as the WikiText-103
                                                  benchmark, we show that DEQs 1) often improve performance over these state-
                                                  of-the-art models (for similar parameter counts); 2) have similar computational
                                                  requirements to existing models; and 3) vastly reduce memory consumption (often
                                                  the bottleneck for training large sequence models), demonstrating an up-to 88%
                                                  memory reduction in our experiments. The code is available at https://github.
                                                  com/locuslab/deq.


                                         1   Introduction
                                         Most modern feedforward deep networks are built on the core concept of layers. In the forward pass,
                                         each network consists of a stack of some L transformations, where L is the depth of the network. To
                                         update these networks, the backward passes rely on backpropagating through the same L layers via the
                                         chain rule, which typically necessitates that we store the intermediate values of these layers. The value
                                         for L is usually a hyperparameter and is picked by model designers (e.g., ResNet-101 [25]). Among
                                         the many applications of deep networks, sequence modeling has witnessed continuous advances in
                                         model architectures. Specifically, while recurrent networks have long been the dominant model for
                                         sequences [21, 26, 14, 34], deep feedforward architectures based on temporal convolutions [49, 47, 7]
                                         and self-attention [48, 16, 13] have (re-)emerged to claim superior performance on a variety of
                                         sequence prediction tasks.
                                         In very general terms, a deep feedforward sequence model can be written as the following iteration:
                                                                  [i+1]    [i] [i]      
                                                                 z1:T = fθ z1:T ; x1:T     for i = 0, 1, 2, . . . , L − 1                 (1)
                                                                        [i]
                                         where i is the layer index; z1:T is the hidden sequence of length T at layer i; x1:T is the input
                                         sequence (i.e., we are choosing to explicitly model skip connections, for reasons we explain later);
                                               [i]
                                         and fθ is some nonlinear transformation which typically enforces causality (i.e., future time points
                                         cannot influence past ones). Our paper derives its motivation from surprising recent works that
                                                                                                                             [i]
                                         employ the same transformation in each layer (known as weight tying, with fθ = fθ , ∀i) and still
                                         achieve results competitive with the state-of-the-art [18, 8, 15]. This raises an interesting question: If
                                         the same transformation is applied at each layer of a deep network, what is the limit of this process,
                                         and how do we model it?

                                         33rd Conference on Neural Information Processing Systems (NeurIPS 2019), Vancouver, Canada.
In this paper, we propose a new approach to “deep” modeling that addresses this question. Specifically,
we introduce the deep equilibirum model (DEQ), a method that directly computes the fixed point
z?1:T of a nonlinear transformation, i.e., the solution to the nonlinear system
                                       z?1:T = fθ (z?1:T ; x1:T ).                                  (2)
This solution corresponds to the eventual hidden layer values of an infinite depth network. But instead
of finding this value by iterating the model, we propose to directly (and in practice, more quickly)
solve for the equilibrium via any black-box root-finding method. Importantly, we show that DEQ
can directly differentiate through the fixed point equations via implicit differentation, which does not
require storing any intermediate activation values. In other words, we can backpropagate through the
infinite-depth network while using only constant memory, equivalent to a single layer’s activations.
After developing the generic DEQ approach, we study in detail the instantiation of DEQ via two
feedforward sequence models: trellis networks (weight-tied temporal convolutions) [8] and memory-
augmented universal transformers (weight-tied multi-head self-attention) [18, 16], both of which
have obtained state-of-the-art performance (SOTA) on various sequence tasks. We show how both
the forward and backward passes can be implemented efficiently via quasi-Newton methods. Finally,
we demonstrate via experiments on large-scale high-dimensional sequence modeling benchmarks
(e.g., WikiText-103 language modeling) that, despite only using constant memory, DEQ can attain
modeling accuracy on par with (or even slightly better than) corresponding layer-based networks. We
believe that DEQ offers a novel perspective on the analysis of sequential data.

2   Background
Deep sequence models. Given an input sequence x1:T = [x1 , . . . , xT ] ∈ RT ×p , where xi ∈ Rp
(e.g., a word embedding) and T ∈ N is the sequence length, we define a sequence model as any
function G that produces output G(x1:T ) = y1:T =∈ RT ×q that satisfies the causality constraint: yt
depends only on x1:t and not on any element of xt+1:T . Recent progress on autoregressive sequence
tasks has been based on deep learning, where three major families of sequence models stand out.
Recurrent networks (RNNs) [21, 51] as well as their variants such as LSTM [26] are universally
applied and optimized in a variety of time-series tasks [9, 22, 34]. Alternatively, prior work has
shown that deeply stacked temporal convolutions [49, 47, 17, 7] can achieve competitive results,
especially on long sequences. Finally, the self-attention transformer architecture [48, 16] has also
achieved SOTA on several NLP benchmarks [19, 13]. Efforts have also been devoted to drawing
deeper connections among the three model families. Bai et al. [8] study the underlying relationship
between RNNs and ConvNets, unifying these in the Trellis Network, which combines the benefits
of both families. Dehghani et al. [18] introduce a recurrently-stacked universal transformer and
demonstrate its effectiveness on text understanding and generation.
Memory-efficient deep networks. An important factor that limits the development of high-
capacity networks is limited memory on hardware devices used for training. To address this issue,
[12]√proposes gradient checkpointing that reduces an L-layer network’s memory requirement to
O( L) at the cost of extra forward passes (i.e., extra computations). Alternatively, [23, 30] develop
reversible networks, where each layer’s activations can be reconstructed from the next layer during
backpropagation to reduce memory requirements. DEQs reduce memory consumption to a constant
(i.e., independent of network “depth”) by directly differentiating through the equilibrium point and
thus circumventing the construction and maintenance of “layers”.
Continuous view of deep networks. Some prior works have studied continuous views of deep
networks. [41] proposes a biologically inspired equilibrium propagation framework for an energy-
based model whose prediction is the fixed-point of the energy dynamics at its local minimum. [24, 11]
model deep ResNets by black-box ODE solvers in forward and backward passes (as if the network
has smaller “layer steps”) given the start- and end-points of a dynamical system. For deep sequence
models, [43, 36] consider the RNN as a dynamical system to investigate its stability properties.
Our work takes a further step in the direction of the aforementioned areas. While some of the prior
work has primarily focused on the analysis of residual architectures or small symmetric-weight
energy-based models, our work is not predicated on any specific type of interlayer transformation.
We show that DEQs can be easily instantiated via two very different sequence learning architectures.
More fundamentally, unlike ODE-based methods, which use the adjoint system to backpropagate


                                                   2
through the entire latent trajectory, the DEQ model solves directly for sequence-level equilibria via
a quasi-Newton method and backpropagates directly through this fixed point, without regard for
the solution path that brought it there. Moreover, while ODE-based models [24, 11] were verified
on numerical experiments and MNIST classification, computation and numerical stability issues
challenge their application to large-scale problems. In comparison, we demonstrate the applicability
of DEQs on realistic high-dimensional sequence tasks with competitive performance, while enjoying
similar constant-memory benefits as [11].
Implicit layers in deep learning. The DEQ model can be viewed as an infinitely deep network,
but interestingly can also be viewed as a single-layer network, with the caveat that the layer is defined
implicitly: the output z?1:T is defined as the value which solves some non-linear equation. There has
been a growing interest in implicit layers in recent years [37, 3, 37, 50], but the precise formulation
of the DEQ is quite different, and our current models represent the largest-scale practical application
of implicit layers in deep learning of which we are aware. Concurrent work [20] also looks at such
implicit layers in a broad sense and focuses on training small models via Lagrangian methods; a
combination of these approaches with the DEQ model is a promising avenue for future work.
Another thread of work on implicit layers traces back to some of the original papers on recurrent
networks trained via recurrent backpropagation (RBP) [2, 38]. Recent work [28] has re-examined RBP
and established an implicit, constant-memory variant based on conjugate gradient and Neumann series.
A number of related papers also enforce fixed point conditions within RNN architectures [54, 27].
Whereas the DEQ model shares similarities with the RBP approach, some major differences involve:
1) the explicit use of equilibrium as a replacement for depth in general networks, along with our proof
of the universality of these models to replace depth; 2) the use of the approach in methods outside
of fixed-input RNNs (i.e., same input vector xt for all t), especially the compatibility with SOTA
architectures; and 3) the scalability of the DEQ model to practical tasks where it achieves results on
par with the current SOTA, whereas RBP has typically been applied in small-scale settings.

3     The Deep Equilibrium Sequence Model
We broadly consider the class of weight-tied deep sequence models (with passthrough connections
from the input to each layer), which consist of the update
             [i+1]        [i]                                     [0]                     [L]
            z1:T = fθ (z1:T ; x1:T ),    i = 0, . . . , L − 1,   z1:T = 0,   G(x1:T ) ≡ z1:T          (3)
We note that this model encapsulates classes such as the trellis network [8] and the universal
transformer [18] (which is typically not written with passthrough connections, but this is a trivial
modification). Such weight-tying is generally considered to come with four major benefits: 1) it
acts as a form of regularization that stabilizes training and supports generalization; 2) it significantly
reduces the model size; 3) it is trivial to show that any deep network can be represented by a
weight-tied deep network of equal depth and only a linear increase in width (see Appendix C); and
4) the network can be unrolled to any depth, typically with improved feature abstractions as depth
increases [8, 18]. However, in practice almost all such models (and deep nets in general) are stacked,
trained and evaluated by unrolling a pre-determined, fixed number of layers. One reason is the limited
memory on training hardware: the models need to store intermediate hidden units for backpropagation
and thus cannot be trained beyond a certain depth that depends on the available memory.
In principle, the network could have infinite depth. This is attained in the limit of unrolling a weight-
tied model for an ever higher number of layers. What is the limit of this process? In practice, for
certain classes of fθ (discussed later), we hypothesize and observe that such weight-tied models
tend to converge to a fixed point as depth increases towards infinity (see Appendix D for empirical
evidence). In other words, as each layer refines the previous one by combining temporal features
across the sequence, increasing depth towards infinity brings “diminishing returns”: each additional
layer has a smaller and smaller contribution until the network reaches an equilibrium:
                            [i]              [i]
                      lim z1:T = lim fθ z1:T ; x1:T ≡ fθ z?1:T ; x1:T ) = z?1:T
                                                      
                                                                                                      (4)
                     i→∞           i→∞


3.1   The Deep Equilibrium Approach

We introduce the deep equilibrium model (DEQ) which, instead of iteratively stacking fθ , directly
solves for and differentiates through the equilibrium state.


                                                     3
3.1.1   Forward Pass
Unlike a conventional network where the output is the activations from the Lth layer, the output of
a DEQ is the equilibrium point itself. Therefore, the forward evaluation could be any procedure
that solves for this equilibrium point. Conventional deep sequence networks, if they converge to an
equilibrium, can be considered a form of fixed-point iterations:
                               [i+1]      [i]       
                              z1:T = fθ z1:T ; x1:T    for i = 0, 1, 2, . . .                   (5)
One can alternatively use other methods that provide faster convergence guarantees.   For notational
convenience, we define gθ and rewrite Eq. (4) as gθ (z?1:T ; x1:T ) = fθ z?1:T ; x1:T − z?1:T → 0. The
equilibrium state z?1:T is thus the root of gθ , which we can find more easily with Newton’s method or
quasi-Newton methods (e.g., Broyden’s method [10]):
                         [i+1]     [i]             [i]
                        z1:T = z1:T − αBgθ (z1:T ; x1:T ) for i = 0, 1, 2, . . .                     (6)
                                                                            [i]
where B is the Jacobian inverse (or its low-rank approximation) at z1:T , and α is the step size. But
generally, one can exploit any black-box root-finding algorithm to solve for the equilibrium point in
                                             [0]
the forward pass, given an initial estimate z1:T (which we set to 0): z?1:T = RootFind(gθ ; x1:T )

3.1.2   Backward Pass
A major problem with using a black-box RootFind is that we are no longer able to rely on explicit
backpropagation through the exact operations in the forward pass. While one can certainly fix an
algorithm (say Newton’s method) to obtain the equilibrium, and then store and backpropagate through
all the Newton iterations, we provide below an alternative procedure that is much simpler, requires
constant memory, and assumes no knowledge of the black-box RootFind.
Theorem 1. (Gradient of the Equilibrium Model) Let z?1:T ∈ RT ×d be an equilibrium hidden
sequence with length T and dimensionality d, and y1:T ∈ RT ×q the ground-truth (target) sequence.
Let h : Rd → Rq be any differentiable function and let L : Rq × Rq → R be a loss function (where
h, L are applied in a vectorized manner) that computes
                      ` = L(h(z?1:T ), y1:T ) = L(h(RootFind(gθ ; x1:T )), y1:T ).                   (7)
Then the loss gradient w.r.t. (·) (for instance, θ or x1:T ) is
     ∂`      ∂`           ∂fθ (z?1:T ; x1:T )     ∂` ∂h                ∂fθ (z?1:T ; x1:T )
         = − ? Jg−1  ?                         = −           Jg
                                                               −1
                                                                   ?                         ,       (8)
    ∂(·)    ∂z1:T θ z1:T         ∂(·)              ∂h ∂z?1:T    θ z1:T         ∂(·)
where Jg−1
        θ  x
             is the inverse Jacobian of gθ evaluated at x.

The proof is provided in Appendix A. The insight provided by Theorem 1 is at the core of our method
and its various benefits. Importantly, the backward gradient through the “infinite” stacking can be
represented as one step of matrix multiplication that involves the Jacobian at equlibrium. For instance,
an SGD update step on model parameters θ would be
                                    ∂`         ∂`            ∂fθ (z?1:T ; x1:T )
                    θ+ = θ − α ·       = θ + α ? Jg−1 z ?                         .                  (9)
                                    ∂θ        ∂z1:T θ
                                                        1:T           ∂θ
Note that this result is independent of the root-finding algorithm we choose or the internal structure of
the transformation fθ , and thus does not require any storage of the intermediate hidden states, which
is necessary for backpropagation in conventional deep networks.

3.1.3   Accelerating DEQ by Approximating the Inverse Jacobian
One challenge of enforcing the forward and backward passes described in Sections 3.1.1 and 3.1.2 is
the cost of computing the exact inverse Jacobian Jg−1
                                                    θ
                                                       at every intermediate Newton iteration. We
propose to address this using Broyden’s method [10], a quasi-Newton approach that makes low-rank
updates to approximate Jg−1θ
                             via the Sherman-Morrison formula [42]:
                                                                  [i]   [i+1]
                                                   ∆z[i+1] − Bgθ ∆gθ                    >
                 Jg−1
                   θ  z
                                [i+1]
                       [i+1] ≈ Bg
                                 θ
                                      = Bg[i]θ +          > [i]  [i+1]
                                                                                ∆z[i+1] Bg[i]θ ,    (10)
                       1:T
                                                   ∆z[i+1] Bgθ ∆gθ

                                                         4
                     [i+1]    [i]          [i+1]         [i+1]               [i]
where ∆z[i+1] = z1:T − z1:T and ∆gθ             = gθ (z1:T ; x1:T ) − gθ (z1:T ; x1:T ). Initially, we set
  [0]                                                                         [i]
Bgθ = −I and the Broyden iterations are stopped when either the norm of gθ falls below a tolerance
ε or when the maximum number of iterations is reached. This lets us avoid the cubic cost induced by
the inverse operation.
A similar idea can be used for the backward pass as well. Specifically, to compute − ∂z∂`      Jg−1
                                                                                                          
                                                                                          ?           ?
                                                                                          1:T     θ  z1:T
in Theorem 1, we can alternatively solve the linear system
                                                            >
                                                        ∂`
                                   Jg>θ z? x> +
                                             
                                                                  = 0,                                (11)
                                         1:T          ∂z?1:T
where the first term (a vector-Jacobian product) can be efficiently computed via autograd packages
(e.g., PyTorch [45]) for any x, without explicitly writing out the Jacobian matrix. Such linear systems
can generally be solved by any indirect methods that leverage fast matrix-vector products; we thus
propose to also rely on Broyden’s method (other indirect methods would also suffice) to solve for
Eq. (11) and directly backpropagate through the equilibrium by Theorem 1 in the backward pass.

3.2   Properties of Deep Equilibrium Models

Section 3.1 develops a sequence model that, while still based on the deep learning philosophy, is quite
different from other approaches in the field, as its output is agnostic to the choice of the RootFind
algorithm in the forward pass. We now discuss some implications of the DEQ approach.
Memory cost of DEQ. An important benefit of DEQ is its extreme memory efficiency. As outlined
in Section 3.1.3, since we are able to use any root-finding algorithm for both the forward and backward
passes (e.g., Broyden’s method [10]), a DEQ only needs to store z?1:T (the equilibrium sequence),
x1:T (input-related, layer-independent variables), and fθ for the backward pass. Note that as we
only need the vector-Jacobian product (with dimension N × T d, where N is the minibatch size) in
Eq. (11), we never need to explicitly construct the Jacobian Jg>θ z? , which could be prohibitively
                                                                       1:T
large on long and high-dimensional sequences (with dimension N × (T d)2 ). Compared to other deep
networks, DEQs therefore offer a constant-memory alternative that enables models that previously
required multiple GPUs and other implementation-based techniques (e.g., half-precision or gradient
checkpointing [12, 13]) to fit easily into a single GPU.
The choice of fθ . Our analysis in Sections 3.1.1, 3.1.2, and 3.1.3 is independent of the choice of
fθ , and the same kind of memory benefit is present regardless of the type of fθ . However, to find
the equilibrium in a reliable and efficient manner, generally fθ needs to be stable and constrained.
The two instantiations we provide in Section 4 are examples of stable transformations. (The gated
activation in TrellisNet and layer normalization in the transformer constrain the output ranges.)
Stacking the DEQ? A natural question arises: if one DEQ is good, can we get additional benefits
by “stacking” DEQs (with potentially different classes of transformations)? The answer, somewhat
surprisingly, is no, as evidenced by the following theorem, which is proved in Appendix B. The
theorem essentially shows that stacking multiple DEQs does not create extra representational power
over a single DEQ.
Theorem 2. (Universality of “single-layer” DEQs.) Let x1:T ∈ RT ×p be the input sequence,
and θ[1] , θ[2] the sets of parameters for stable transformations fθ[1] : Rr × Rp → Rr and vθ[2] :
Rd × Rr → Rd , respectively. Then there exists ΓΘ : Rd+r × Rp → Rd+r , where Θ = θ[1] ∪ θ[2] , s.t.
             z?1:T = RootFind gθf[2] ; RootFind gθv[1] ; x1:T = RootFind gΘΓ
                                                                                 
                                                                             ; x1:T [:,−d:] ,  (12)
where [·][:,−d:] denotes the last d feature dimensions of [·].

4     Instantiations of DEQ
While the forward and backward analyses of DEQ do not depend on the internal structure of fθ ,
in this section we briefly highlight two examples of fθ as specific instantiations of DEQ. Both
models (TrellisNet [8] and self-attention [48, 18]) achieve state-of-the-art results on various sequence
modeling benchmarks. Importantly, through these two very different models and their properties,
we illustrate the compatibility of the DEQ approach with all three major families of existing deep
sequence networks: transformers, RNNs, and temporal convolutional networks (TCNs).

                                                    5
                                                                                                            = Memory storage needed at training time
                                                                                                             [L]
      Deep Equilibrium Models                                                                               z1:T ! z?1:T                             at which
                                                                               Depth                        as L ! 1                                 f✓ (x; . . . ) = x
      Weight-tied Deep Networks z [0] ! z [1] ! . . .
Output z   [i+1]
                                                                                                   [L]
                                                                                                  z1:T                                     z?1:T
                                      y=x
                                                                                        Forward                                  Forward
                                                                                                            ⇥L layers
                                          f✓ (x)                                                                             Equilibrium Solver for
                                                                                        z[i+1] = f✓ (z[i] ; x)               z⇤ = f✓ (z⇤ ; x)
 y                                                                                                        Backward                                 Backward
                                           g✓ (x) = f✓ (x)
                                                        Historyx(or zero) padding                                                           [0]
                                                                                                   [0]                                     z1:T
                                                         (i.e., previous equilibrium)             z1:T
                                                         Input injection
                                                         Positional embedding                     x̃1:T                                    x̃1:T
                                                         ...
                   z?   z [2] z [1]     z [0] Input z [i]           Fixed                                                                       Time
                            x                                                 Typical Deep Neural Network                   Deep Equilibrium Model

(a) A simple illustration of solving for (b) A deep equilibrium model operates with significantly less memory
an equilibrium point in 2D.              than conventional deep nets due to an analytical backward pass.
               Figure 1: Comparison of the DEQ with conventional weight-tied deep networks.
Trellis networks. We briefly introduce the trellis network (TrellisNet) here and refer interested
readers to [8] for a detailed description. Generally, TrellisNet is a TCN with two modifications. First,
a linear transformation of the original input sequence x1:T is added to the convolutional outputs at
all layers. Second, the convolutional kernel weights are tied across the depth of the network (i.e.,
TrellisNet is a weight-tied TCN). Thus we can write TrellisNet with convolutional kernel size k,
dilation s, and nonlinearity ψ in DEQ form as
                 x̃1:T = Input injection (i.e., linearly transformed inputs by Conv1D(x1:T ; Wx ))
     fθ (z1:T ; x1:T ) = ψ(Conv1D([u−(k−1)s: , z1:T ]; Wz ) + x̃1:T )
where u−(k−1)s: is typically: 1) the last (k − 1)s elements of the previous sequence’s output (if
using history padding [8]); or 2) simply zero-padding. [·, ·] means concatenation along the temporal
dimension. Following [8], we use the LSTM gated activation for ψ.
Weight-tied transformers. At a high level, multi-head self-attention transformers [48] are very
different from most deep networks. Instead of convolutions or recurrence, a self-attention layer maps
the input into Q (query), K (key), and V (value) and computes the attention score between time-steps
ti and tj as [QK > ]i,j . This attention score is then normalized via softmax and multiplied with the
V sequence to produce the output. Since the transformer is order-invariant, prior work proposed to
add positional embeddings (PE) [48, 16] to the self-attention operation. Following this design, [18]
further proposed the universal transformer, which “recurrently stacks” the transformer’s self-attention
and transition function block φ through a number of layers. Referring readers to [48, 16, 18] for more
details, we write a weight-tied transformer in the DEQ form as
                               x̃1:T = Input injection (i.e., linearly transformed inputs by x1:T Wx )
                   fθ (z1:T ; x1:T ) = LN(φ(LN(SelfAttention(z1:T WQKV + x̃1:T ; PE1:T ))))
where WQKV ∈ Rd×3d produces the Q, K, V for the multi-head self-attention, and LN stands for
layer normalization [5]. Note that we add input injection x̃1:T to Q, K, V in addition to the positional
                                  [0]
embedding and initialize with z1:T = 0. Following prior work [48, 19, 16, 18], we use a 2-layer
positionwise feedforward residual block for φ. In our implementation, we use the memory-augmented
transformer proposed by [16], where we feed [z?−T 0 : , z1:T ] (i.e., with history padding of length T 0 )
and relative positional embedding PE−T 0 :T to the self-attention operation.
Figure 1 provides a generic comparison between these conventional weight-tied deep networks and
the DEQ approach, highlighting the constant memory requirements of the latter.

5    Experiments
We evaluate DEQ on both synthetic stress tests and realistic large-scale language modeling (where
complex long-term temporal dependencies are involved). We use the two aforementioned instantia-
tions of fθ in DEQ. On both WikiText-103 [35] (which contains >100M words and a vocabulary
size of >260K) and the smaller Penn Treebank corpus (where stronger regularizations are needed for


                                                                               6
           Table 1: DEQ achieves strong performance on the long-range copy-memory task.
                                                                Models (Size)
                              DEQ-Transformer (ours) (14K)    TCN [7] (16K) LSTM [26] (14K)      GRU [14] (14K)
 Copy Memory T =400 Loss                  3.5e-6                 2.7e-5          0.0501              0.0491


Table 2: DEQ achieves competitive performance on word-level Penn Treebank language modeling
(on par with SOTA results, without fine-tuning steps [34]). † The memory footprints are benchmarked
(for fairness) on input sequence length 150 and batch size 15, which does not reflect the actual
hyperparameters used; the values also do not include the memory for word embeddings.
                             Word-level Language Modeling w/ Penn Treebank (PTB)
                                                                Non-embedding
                         Model                      # Params                     Test perplexity      Memory†
                                                                  model size
                 Variational LSTM [22]                  66M                 -             73.4            -
                     NAS Cell [55]                      54M                 -             62.4            -
      NAS (w/ black-box hyperparameter tuner) [32]      24M               20M             59.7            -
                   AWD-LSTM [34]                        24M               20M             58.8            -
      DARTS architecture search (second order) [29]     23M               20M             55.7            -
 60-layer TrellisNet (w/ auxiliary loss, w/o MoS) [8]   24M               20M             57.0         8.5GB
               DEQ-TrellisNet (ours)                    24M               20M             57.1         1.2GB

conventional deep nets) for word-level language modeling, we show that DEQ achieves competitive
(or better) performance even when compared to SOTA methods (of the same model size, both weight-
tied and not) while using significantly less memory. We provide a more detailed introduction of the
tasks and datasets in Appendix F.
Setting. Both instantiations of DEQ use Broyden’s method [10] to avoid direct computation of the
inverse Jacobian, as described in Section 3.1.3. We note that the use of DEQ implicitly introduces a
new “hyperparameter” – the stopping criterion for Broyden
                                                       √       iterations.√During training, we set this
                                                                 −5
tolerance ε of forward and backward passes
                                        √      to  ε =   T  · 10     and T · 10−8 , respectively. At
                                                 −2
inference, we relax the tolerance to ε = T · 10 (or we can use a smaller maximum iteration limit
for Broyden’s method; see discussions later). For the DEQ-TrellisNet instantiation, we roughly follow
the settings of [8]. For DEQ-Transformers, we employ the relative positional embedding [16], with
sequences of length 150 at both training and inference on the WikiText-103 dataset. Implementations
and pretrained models can be found at https://github.com/locuslab/deq.

5.1     Copy Memory Task

The goal of the copy memory task is simple: to explicitly test a sequence model’s ability to exactly
memorize elements across a long period of time (see Appendix F). As shown in Table 1, DEQ
demonstrates good memory retention over relatively long sequences (T = 400), with substantially
better results than recurrent architectures such as LSTM/GRU (consistent with the findings in [7]).

5.2     Large-Scale Language Modeling

One issue encountered in prior works that take a continuous view of deep networks [11, 24] is
the challenge of scaling these approaches to real, high-dimensional, large-scale datasets. In this
subsection, we evaluate the DEQ approach on some large-scale language datasets and investigate its
effectiveness as a practical “implicit-depth” sequence model.
Performance on Penn Treebank. Following the set of hyperparameters used by [8] for TrellisNet,
we evaluate the DEQ-TrellisNet instantiation on word-level language modeling with the PTB corpus.
Note that without an explicit notion of “layer”, we do not add auxiliary losses, as was done in [8]. As
shown in Table 2, when trained from scratch, the DEQ-TrellisNet achieves a test perplexity on par
with the original deeply supervised TrellisNet.
Performance on WikiText-103. On the much larger scale WT103 corpus (about 100x larger than
PTB), the DEQ-TrellisNet achieves better test perplexity than the original deep TrellisNet. For the
Transformer instantiation, we follow the design of the Transformer-XL model [16]. We specifically
compare to a “medium” Transformer-XL model (the largest released model that can fit on GPUs)


                                                        7
Table 3: DEQ-based models are competitive with SOTA deep networks of the same model size on the
WikiText-103 corpus, with significantly less memory. † See Table 2 for more details on the memory
benchmarking. Transformer-XL models are not weight-tied, unless specified otherwise.
                                                                   Word-level Language Modeling w/ WikiText-103 (WT103)
                                                                                                         Non-Embedding
                                                                Model                         # Params                                                            Test perplexity         Memory†
                                                                                                           Model Size
                   Generic TCN [7]                                                                                            150M                  34M                 45.2                   -
              Gated Linear ConvNet [17]                                                                                       230M                    -                 37.2                   -
                   AWD-QRNN [33]                                                                                              159M                 51M                  33.0                7.1GB
             Relational Memory Core [40]                                                                                      195M                  60M                 31.6                   -
 Transformer-XL (X-large, adaptive embed., on TPU) [16]                                                                       257M                 224M                 18.7               12.0GB
                               70-layer TrellisNet (+ auxiliary loss, etc.) [8]                                               180M                  45M                 29.2               24.7GB
                              70-layer TrellisNet with gradient checkpointing                                                 180M                  45M                 29.2                5.2GB
                                          DEQ-TrellisNet (ours)                                                               180M                  45M                 29.0               3.3GB
          Transformer-XL (medium, 16 layers)                                                                                  165M                  44M                 24.3                8.5GB
          DEQ-Transformer (medium, ours).                                                                                     172M                  43M                 24.2                2.7GB
  Transformer-XL (medium, 18 layers, adaptive embed.)                                                                         110M                  72M                 23.6                9.0GB
  DEQ-Transformer (medium, adaptive embed., ours)                                                                             110M                  70M                 23.2                3.7GB
                                            Transformer-XL (small, 4 layers)                                                  139M                 4.9M                 35.8                4.8GB
                                      Transformer-XL (small, weight-tied 16 layers)                                           138M                 4.5M                 34.9                6.8GB
                                            DEQ-Transformer (small, ours).                                                    138M                 4.5M                 32.4                1.1GB

                                                DEQ-Transformer on WT103 (Seq. Length=150)                                               DEQ-Transformer on WT103 (Seq. Length=150)
                                                                                                                               103
   # of Broyden Iter. per Time Step




                                      0.9                                                                                      102
                                                                                                 Difference Norm ||f(x)-x||


                                      0.8                                                                                      101
                                      0.7                                                                                      100
                                      0.6                                                                                     10 1                                 Weight-tied Trans. (Ep. 1)
                                                                                                                              10 2                                 Weight-tied Trans. (Ep. 12)
                                      0.5                                  Forward (eps=1e-6)                                                                      DEQ-Trans. (Ep. 1)
                                                                           Backward (eps=1e-8)                                10 3                                 DEQ-Trans. (Ep. 12)
                                      0.4
                                                                                                                              10 4
                                            0        2      4        6       8     10     12                                         0       50      100   150    200    250     300     350
                                                                Training Epoch                                                                    Number of Function Evaluations
Figure 2: Left: number of Broyden iterations in forward and backward passes gradually grows with
epochs. Right: DEQ-Transformer finds the equilibrium in a stable and efficient manner (whereas the
deep transformer could oscillate around the fixed point, even when one exists).
and a “small” Transformer-XL model, while noting that the largest Transformer-XL network has
massive memory requirements (due in part to very wide hidden features, batch sizes, and training-time
sequence lengths, which would not be decreased by a DEQ) and can only be trained on TPUs [16].
In Table 3, we show that the DEQs yield competitive performance, outperforming prior SOTA
approaches such as [16] on similar model sizes while consuming much less memory during training.
Memory footprint of DEQ. For conventional deep networks with L layers, the training memory
complexity is O(L) since all intermediate activations are stored for backpropagation. In comparison,
DEQs have an O(1) (i.e., constant) memory footprint due to the root-finding formulation. We
benchmark the reduced memory consumption in the last column of Tables 2 and 3, with controlled
sequence lengths and batch sizes for fairness. On both instantiations, the DEQ approach leads
to an over 80% (up to 88%) reduction in memory consumption by the model (excluding word
embeddings, which are orthogonal to the comparison here). Moreover, we empirically verify (using
a 70-layer TrellisNet) that DEQ consumes even less memory than gradient checkpointing     √ [12], a
popular technique that reduces the memory required to train a layer-based model to O( L). Note
that the DEQ’s memory footprint remains competitive even when compared with baselines that are
not weight-tied (a reduction of over 60%), with similar or better accuracy.
Initialization of DEQ. To train DEQ models, it is critical to ensure that the model is stable,
such that the equilibrium state can be reliably approximated via quasi-Newton methods. While we
found that the most commonly used initialization schemes with small values (around 0) suffice,
it is generally important to make sure that DEQ starts with a small operator norm in the weight
matrices. For both DEQ-TrellisNet and DEQ-Transformer, we observe that they are not sensitive
to any specific initialization scheme since non-linearities such as σ/tanh and LayerNorm also help
make fθ contractive (and stable). We initialize the parameters of fθ by sampling from N (0, 0.05).

                                                                                                 8
Table 4: Runtime ratios between DEQs and corresponding deep networks at training and inference
(> 1× implies DEQ is slower). The ratios are benchmarked on WikiText-103.
                                                    DEQ / 18-layer Transformer                                        DEQ / 70-layer TrellisNet
                                                    Training      Inference                                           Training     Inference
                                                     2.82×                   1.76×                                        2.40×          1.64×

                                                    DEQ-Transformer on WT103                                                        DEQ-Transformer on WT103
                            200                                                                                      29
                                         DEQ-Transformer                                                                                                         DEQ-Transformer
                            175
                                                                                                                     28




                                                                                             Validation Perplexity
    Validation Perplexity




                            150
                            125                                                                                      27
                            100                                                                                      26
                             75                                                                                      25
                             50                                                                                      24
                             25
                                  10 6      10 5     10 4   10 3     10 2    10 1      100                                    20         40          60          80         100
                                               Forward Threshold Epsilon (Step Avg.)                                               Forward Broyden Iteration Limit
Figure 3: DEQ can be accelerated by leveraging higher tolerance ε (left) or a lower Broyden iteration
limit (right). In general, poor estimates of the equilibrium can hurt DEQ performances.
Convergence to equilibrium. The deep equilibrium model does not have “layers”. One factor that
affects computation time in DEQs is the number of Broyden iterations in forward/backward passes,
where each forward Broyden step evaluates fθ once, and a backward step computes a vector-Jacobian
product. We find that in general the number of Broyden iterations gradually increases with training
epochs (Figure 2, left, where the y-axis is computed by TotalSequence
                                                               Broyden Iterations
                                                                      Length      ), an observation similar to
the one reported for training Neural ODEs [11]. One factor contributing to this phenomenon could be
that the training pushes the operator norm of Jfθ to larger values, making the fixed point harder to
solve. Meanwhile, the backward pass requires much fewer iterations than the forward, primarily due
to the simplicity of the linear system in Eq. (11). We also find that DEQs can almost always converge
to the sequence-level fixed point, much more efficiently than original weight-tied transformers (Figure
2, right). Note that after 12 epochs, deeply stacked self-attention tends to oscillate around the fixed
point, while DEQs exhibit stable convergence with the quasi-Newton method.
Broyden iterations and the runtime of DEQ. Unlike conventional deep networks that come with
a fixed number L of layers, the runtime of DEQ depends strongly on the number of Broyden steps to
reach the equilibrium. Therefore, it’s challenging to fairly compare the runtimes of implicit-depth
models like DEQ with those of corresponding weight-tied deep networks (e.g., using higher depth
necessarily takes longer to run). Ideally, the values of ε should be as small as possible so as to ensure
that the analytical gradients from Theorem 1 are accurate. However, we empirically observe that using
a higher ε or a lower iteration limit allows the DEQ to be trained and evaluated much faster with only
a small degradation in performance. For instance, generally we find ε < 0.1 or an iteration limit of 30
(on sequence length 75) to be sufficient for competitive performance. Figure 3 visualizes this tradeoff
on a medium DEQ-Transformer (without adaptive embedding). Note that accuracy quickly diverges
when tolerance ε is too large (Figure 3, left), suggesting that a poor estimate of the equilibrium can
hurt DEQ performances. Table 4 provides approximate runtimes for competitive-accuracy DEQs on
WikiText-103. DEQs are typically slower than layer-based deep networks.
Additional empirical remarks as well as training tips are provided in Appendix E.

6              Conclusion
Deep networks have predominantly taken the form of stacks of layers. We propose the deep equi-
librium approach (DEQ), which models temporal data by directly solving for the sequence-level
fixed point and optimizing this equilibrium for better representations. DEQ needs only O(1) memory
at training time, is agnostic to the choice of the root solver in the forward pass, and is sufficiently
versatile to subsume drastically different architectural choices. Our experiments have shown that
DEQs have good temporal memory retention, are able to scale to realistic, large-scale sequence tasks,
and perform competitively with, or slightly outperform, SOTA methods. Overall, we believe that the
DEQ approach provides an interesting and practical new perspective on designing and optimizing
sequence models.


                                                                                             9
References
 [1] Rami Al-Rfou, Dokook Choe, Noah Constant, Mandy Guo, and Llion Jones. Character-level language
     modeling with deeper self-attention. arXiv:1808.04444, 2018.

 [2] Luis B Almeida. A learning rule for asynchronous perceptrons with feedback in a combinatorial environ-
     ment. In Artificial Neural Networks. 1990.

 [3] Brandon Amos and J Zico Kolter. OptNet: Differentiable optimization as a layer in neural networks. In
     International Conference on Machine Learning (ICML), 2017.

 [4] Martin Arjovsky, Amar Shah, and Yoshua Bengio. Unitary evolution recurrent neural networks. In
     International Conference on Machine Learning (ICML), 2016.

 [5] Lei Jimmy Ba, Ryan Kiros, and Geoffrey E. Hinton. Layer normalization. arXiv:1607.06450, 2016.

 [6] Alexei Baevski and Michael Auli. Adaptive input representations for neural language modeling. In
     International Conference on Learning Representations (ICLR), 2019.

 [7] Shaojie Bai, J. Zico Kolter, and Vladlen Koltun. An empirical evaluation of generic convolutional and
     recurrent networks for sequence modeling. arXiv:1803.01271, 2018.

 [8] Shaojie Bai, J. Zico Kolter, and Vladlen Koltun. Trellis networks for sequence modeling. In International
     Conference on Learning Representations (ICLR), 2019.

 [9] James Bradbury, Stephen Merity, Caiming Xiong, and Richard Socher. Quasi-recurrent neural networks.
     In International Conference on Learning Representations (ICLR), 2017.

[10] Charles G Broyden. A class of methods for solving nonlinear simultaneous equations. Mathematics of
     Computation, 1965.

[11] Tian Qi Chen, Yulia Rubanova, Jesse Bettencourt, and David K Duvenaud. Neural ordinary differential
     equations. In Neural Information Processing Systems, 2018.

[12] Tianqi Chen, Bing Xu, Chiyuan Zhang, and Carlos Guestrin. Training deep nets with sublinear memory
     cost. arXiv:1604.06174, 2016.

[13] Rewon Child, Scott Gray, Alec Radford, and Ilya Sutskever. Generating long sequences with sparse
     transformers. arXiv:1904.10509, 2019.

[14] Kyunghyun Cho, Bart Van Merriënboer, Dzmitry Bahdanau, and Yoshua Bengio. On the properties of
     neural machine translation: Encoder-decoder approaches. arXiv:1409.1259, 2014.

[15] Raj Dabre and Atsushi Fujita. Recurrent stacking of layers for compact neural machine translation models.
     In AAAI Conference on Artificial Intelligence, 2019.

[16] Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc V. Le, and Ruslan Salakhutdinov.
     Transformer-XL: Attentive language models beyond a fixed-length context. In Annual Meeting of the
     Association for Computational Linguistics (ACL), 2019.

[17] Yann N. Dauphin, Angela Fan, Michael Auli, and David Grangier. Language modeling with gated
     convolutional networks. In International Conference on Machine Learning (ICML), 2017.

[18] Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and Łukasz Kaiser. Universal
     transformers. International Conference on Learning Representations (ICLR), 2019.

[19] Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. BERT: Pre-training of deep
     bidirectional transformers for language understanding. In NAACL-HLT, 2019.

[20] Laurent El Ghaoui, Fangda Gu, Bertrand Travacca, and Armin Askari.               Implicit deep learning.
     arXiv:1908.06315, 2019.

[21] Jeffrey L Elman. Finding structure in time. Cognitive Science, 14(2), 1990.

[22] Yarin Gal and Zoubin Ghahramani. A theoretically grounded application of dropout in recurrent neural
     networks. In Neural Information Processing Systems, 2016.

[23] Aidan N Gomez, Mengye Ren, Raquel Urtasun, and Roger B Grosse. The reversible residual network:
     Backpropagation without storing activations. In Neural Information Processing Systems, 2017.


                                                     10
[24] Eldad Haber and Lars Ruthotto. Stable architectures for deep neural networks. Inverse Problems, 2017.

[25] Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition.
     In Computer Vision and Pattern Recognition (CVPR), 2016.

[26] Sepp Hochreiter and Jürgen Schmidhuber. Long short-term memory. Neural Computation, 9(8), 1997.

[27] Michaeel Kazi and Brian Thompson. Implicitly-defined neural networks for sequence labeling. In Annual
     Meeting of the Association for Computational Linguistics (Short Papers), 2017.

[28] Renjie Liao, Yuwen Xiong, Ethan Fetaya, Lisa Zhang, KiJung Yoon, Xaq Pitkow, Raquel Urtasun, and
     Richard Zemel. Reviving and improving recurrent back-propagation. In International Conference on
     Machine Learning (ICML), 2018.

[29] Hanxiao Liu, Karen Simonyan, and Yiming Yang. DARTS: Differentiable architecture search. In
     International Conference on Learning Representations (ICLR), 2019.

[30] Matthew MacKay, Paul Vicol, Jimmy Ba, and Roger B. Grosse. Reversible recurrent neural networks. In
     Neural Information Processing Systems, 2018.

[31] Mitchell P Marcus, Mary Ann Marcinkiewicz, and Beatrice Santorini. Building a large annotated corpus
     of English: The Penn treebank. Computational Linguistics, 19(2), 1993.

[32] Gábor Melis, Chris Dyer, and Phil Blunsom. On the state of the art of evaluation in neural language models.
     In International Conference on Learning Representations (ICLR), 2018.

[33] Stephen Merity, Nitish Shirish Keskar, and Richard Socher. An analysis of neural language modeling at
     multiple scales. arXiv:1803.08240, 2018.

[34] Stephen Merity, Nitish Shirish Keskar, and Richard Socher. Regularizing and optimizing LSTM language
     models. In International Conference on Learning Representations (ICLR), 2018.

[35] Stephen Merity, Caiming Xiong, James Bradbury, and Richard Socher. Pointer sentinel mixture models. In
     International Conference on Learning Representations (ICLR), 2017.

[36] John Miller and Moritz Hardt. When recurrent models don’t need to be recurrent. arXiv:1805.10369, 2018.

[37] Vlad Niculae, Andre Martins, Mathieu Blondel, and Claire Cardie. SparseMAP: Differentiable sparse
     structured inference. In International Conference on Machine Learning (ICML), 2018.

[38] Fernando J Pineda. Generalization of back propagation to recurrent and higher order neural networks. In
     Neural Information Processing Systems, 1988.

[39] Tim Salimans and Diederik P Kingma. Weight normalization: A simple reparameterization to accelerate
     training of deep neural networks. In Neural Information Processing Systems, 2016.

[40] Adam Santoro, Ryan Faulkner, David Raposo, Jack Rae, Mike Chrzanowski, Theophane Weber, Daan
     Wierstra, Oriol Vinyals, Razvan Pascanu, and Timothy Lillicrap. Relational recurrent neural networks. In
     Neural Information Processing Systems, 2018.

[41] Benjamin Scellier and Yoshua Bengio. Equilibrium propagation: Bridging the gap between energy-based
     models and backpropagation. Frontiers in Computational Neuroscience, 2017.

[42] Jack Sherman and Winifred J Morrison. Adjustment of an inverse matrix corresponding to a change in one
     element of a given matrix. The Annals of Mathematical Statistics, 1950.

[43] Patrice Y Simard, Mary B Ottaway, and Dana H Ballard. Fixed point analysis for recurrent networks. In
     Neural Information Processing Systems, 1989.

[44] Nitish Srivastava, Geoffrey E Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout:
     A simple way to prevent neural networks from overfitting. Journal of Machine Learning Research (JMLR),
     15(1), 2014.

[45] Benoit Steiner, Zachary DeVito, Soumith Chintala, Sam Gross, Adam Paszke, Francisco Massa, Adam
     Lerer, Gregory Chanan, Zeming Lin, Edward Yang, et al. PyTorch: An imperative style, high-performance
     deep learning library. In Neural Information Processing Systems, 2019.

[46] Trieu H Trinh, Andrew M Dai, Thang Luong, and Quoc V Le. Learning longer-term dependencies in
     RNNs with auxiliary losses. In International Conference on Machine Learning (ICML), 2018.


                                                      11
[47] Aäron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal
     Kalchbrenner, Andrew W. Senior, and Koray Kavukcuoglu. WaveNet: A generative model for raw audio.
     arXiv:1609.03499, 2016.

[48] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz
     Kaiser, and Illia Polosukhin. Attention is all you need. In Neural Information Processing Systems, 2017.

[49] Alex Waibel, Toshiyuki Hanazawa, Geoffrey Hinton, Kiyohiro Shikano, and Kevin J Lang. Phoneme
     recognition using time-delay neural networks. IEEE Transactions on Acoustics, Speech, and Signal
     Processing, 37(3), 1989.

[50] Po-Wei Wang, Priya Donti, Bryan Wilder, and Zico Kolter. SATNet: Bridging deep learning and logical
     reasoning using a differentiable satisfiability solver. In International Conference on Machine Learning
     (ICML), 2019.

[51] Paul J Werbos. Backpropagation through time: What it does and how to do it. Proceedings of the IEEE,
     78(10), 1990.

[52] Zhilin Yang, Zihang Dai, Ruslan Salakhutdinov, and William W. Cohen. Breaking the softmax bottleneck:
     A high-rank RNN language model. International Conference on Learning Representations (ICLR), 2018.

[53] Saizheng Zhang, Yuhuai Wu, Tong Che, Zhouhan Lin, Roland Memisevic, Ruslan R Salakhutdinov, and
     Yoshua Bengio. Architectural complexity measures of recurrent neural networks. In Neural Information
     Processing Systems, 2016.

[54] Ziming Zhang, Anil Kag, Alan Sullivan, and Venkatesh Saligrama. Equilibrated recurrent neural network:
     Neuronal time-delayed self-feedback improves accuracy and stability. arXiv:1903.00755, 2019.
[55] Barret Zoph and Quoc V Le. Neural architecture search with reinforcement learning. In International
     Conference on Learning Representations (ICLR), 2017.




                                                     12
A    Backward Pass of the Deep Equilibrium Model
One of the core benefits of the DEQ approach comes from its analytical backward gradient at
equilibrium. In this section, we provide a proof to Theorem 1 (which we restate here).
Theorem 1. (Gradient of the Equilibrium Model) Let z?1:T ∈ RT ×d be an equilibrium hidden
sequence with length T and dimensionality d, and y1:T ∈ RT ×q the ground-truth (target) sequence.
Let h : Rd → Rq be any differentiable function and L : Rq × Rq → R be a loss function (where h, L
are applied in vectorized manner) that computes
                       ` = L(h(z?1:T ), y1:T ) = L(h(RootFind(gθ ; x1:T )), y1:T ).               (13)
Then the loss gradient w.r.t. (·) (for instance, θ or x1:T ) is
     ∂`      ∂`           ∂fθ (z?1:T ; x1:T )     ∂` ∂h              ∂fθ (z?1:T ; x1:T )
         = − ? Jg−1                            = −           J −1
                                                                                           ,      (14)
                                                   ∂h ∂z?1:T gθ z1:T
                     ?
                    z1:T                                          ?
    ∂(·)    ∂z1:T θ
                                 ∂(·)                                        ∂(·)
where Jg−1
        θ  x
             is the inverse Jacobian of gθ evaluated at x.

Proof of Theorem 1. We first write out the equilibrium sequence condition: fθ (z?1:T ; x1:T ) = z?1:T .
By implicitly differentiating two sides of this condition with respect to (·):
               dz?1:T    dfθ (z?1:T ; x1:T )     ∂fθ (z?1:T ; x1:T ) ∂fθ (z?1:T ; x1:T ) dz?1:T
                      =                      =                      +
                d(·)            d(·)                   ∂(·)               ∂z?1:T          d(·)
                            ?                ?                ?
                                       
                      ∂fθ (z1:T ; x1:T ) dz1:T        ∂fθ (z1:T ; x1:T )
             =⇒ I −                               =
                           ∂z?1:T           d(·)              ∂(·)

Since gθ (z?1:T ) = fθ (z?1:T ; x1:T ) − z?1:T , we have
                                                         ∂fθ (z?1:T ; x1:T )
                                                                            
                                   Jgθ z? = − I −                              ,
                                         1:T                  ∂z?1:T
which implies
                       ∂`    ∂` dz?1:T     ∂`           ∂fθ (z?1:T ; x1:T )
                           = ?         = − ? Jg−1  ?
                                                  z1:T
                                                                             .
                      ∂(·)  ∂z1:T d(·)    ∂z1:T θ
                                                               ∂(·)



B    Sufficiency of a Single DEQ “Layer”
A hypothetical extension to the DEQ idea follows from the “deep” philosophy: if one DEQ works so
well, why don’t we stack multiple DEQ modules with different parameters fθ[i] (i = 1, 2, . . . )? We
(re-)state and prove the following theorem, which demonstrates the universality of the DEQ model
(i.e., sufficiency of exactly one DEQ “layer”).
Theorem 2. (Universality of “Single-layer” DEQs) Let x1:T ∈ RT ×p be the input sequence, and
θ[1] , θ[2] the sets of parameters for stable transformations fθ[1] : Rr ×Rp → Rr and vθ[2] : Rd ×Rr →
Rd , respectively. Then there exists ΓΘ : Rd+r × Rp → Rd+r , where Θ = θ[1] ∪ θ[2] s.t.
               z?1:T = RootFind gθv[2] ; RootFind gθf[1] ; x1:T = RootFind gΘ  Γ
                                                                                     
                                                                                 ; x1:T [:,−d:]    (15)

where [·][:,−d:] denotes the last d feature dimensions of [·].

                                 [1]?
Proof of Theorem 2. Assume z1:T = RootFind gθf[1] ; x1:T ∈ Rr is the equilibrium of the first DEQ
                                                               

module under transformation fθ[1] . Define Θ = θ[1] ∪θ[2] , and ΓΘ (w1:T ; x1:T ) : Rd+r ×Rp → Rd+r
by:
                                           " (1) #          "            (1)
                                                                                        #
                                              w1:T                 fθ[1] (w1:T , x1:T )
                 ΓΘ (w1:T ; x1:T ) = ΓΘ          (2) ; x1:T    =           (2)    (1)           (16)
                                              w1:T                vθ[2] (w1:T , w1:T )
               [1]? 
       ?
Then w1:T  = z1:T      is a fixed point of ΓΘ (·; x1:T ), which completes the proof.
               z?1:T

                                                        13
C    Universality of Weight-tied, Input-injected Networks
Although the DEQ model corresponds to an infinite-depth network, as mentioned above it applies
only to the specific case of weight-tied, input-injected infinite-depth models. This seems at first
glance a substantial restriction over traditional deep networks, which have no requirement that the
weights at each layer be identical. However, as we show below, this is not an actual restriction on the
representational capacity from a mathematical point of view. Specifically, any deep network can be
represented as a deep weight-tied network with no increase in depth and only a linear increase in
the size of the hidden layer. This argument is equivalent to that presented in the TrellisNet work [8,
Theorem 1], but we include it here in a slightly simpler and more general form. We emphasize that in
practice we do not use the sparse structure below to construct the weight-tied layers for DEQ, but
instead just use dense matrices Wz and Wx . However, the theorem below is important in establishing
that there is no notable representational loss.
Theorem 3. (Universality of Weight-tied Deep Networks) Consider a traditional L-layer deep
network defined by the relation
                    z[i+1] = σ [i] (W [i] z[i] + b[i] ),    i = 0, . . . , L − 1,   z[0] = x          (17)

where z[i] denotes the hidden features at depth i, W [i] , b[i] are parameters of the network, σ [i] is the
non-linearity at depth i, and x is the original input. Then the same network can be represented by a
weight-tied, input-injected network of equivalent depth
                          z̃[i+1] = σ(Wz z̃[i] + Wx x + b̃), i = 0, . . . , L − 1.                    (18)
where σ, Wz , Wx and b̃ are constant over all layers.

Proof of Theorem 3. The proof is constructive: we build the weight-tied network equivalent to the
original network by contructing the relevant matrices using a simple “shift” operation. In particular,
we define the network parameters as
                                              
        0          0      ...      0        0
                                                                            b[0]              σ [0]
                                                                                                 
                                                          W [0]
                                                               
      W [1]       0      ...      0        0 
                                                         0              b[1]           σ [1] 
                  W [2]
                                              
Wz =  0                  ...      0        0  , Wx =         , b̃ =           , σ =           .
                                                                                                 
                                                           .
                                                         .                 .
                                                                              .               ..
      ..          ..     ..       ..       ..            .                 .                .  
      .            .        .      .        .                             [L−1]             [L−1]
                                                           0               b                σ
            0       0     ...    W [L−1]    0
                                                                                                      (19)
It is clear from inspection that after L applications of the layer, i.e.,
                                        z̃[i+1] = σ(Wz z̃[i] + Wx x + b̃)                             (20)
using these parameters the hidden vector z̃ will take on the value
                                                  [1] 
                                                    z
                                                  z[2] 
                                        z̃[L] =  .  .                                               (21)
                                                        
                                                  .. 
                                                    z[L]
Thus the weight-tied network computes all the same terms as the original network, using the same
depth as the original network, and with a hidden unit size that is just the sum of the individual hidden
unit sizes in the original network. This establises the claim of the theorem.

D    Empirical Convergence of Weight-tied Deep Nets
As mentioned in Section 3, one motivation for optimizing the sequence-level equilibrium comes from
our empirical observations that, starting at some point of the deep stacking, weight-tied deep networks
begin to converge to a fixed point. We show in Figure 4 the convergence of trained layer-based
TrellisNet (weight-tied temporal convolutions) and universal transformer (weight-tied self-attention)
on randomly selected test samples of different lengths T =100, 200, 400 and 800. In both cases, we
see a tendency of the activations to converge. Notably, for transformers, we find stacked iterations


                                                       14
                                                           Trellis Network                                                                  Weight-Tied/Universal Transformer
                                     102                             TrellisNet (Seq. Length=800)                                                  Weight-tied Transformer (Seq. Length=800)
                                                                     TrellisNet (Seq. Length=400)                                                  Weight-tied Transformer (Seq. Length=400)




                                                                                                     Difference Norm ||f(x)-x||
       Difference Norm ||f(x)-x||
                                     101                             TrellisNet (Seq. Length=200)                                 102              Weight-tied Transformer (Seq. Length=200)
                                     100                             TrellisNet (Seq. Length=100)                                                  Weight-tied Transformer (Seq. Length=100)
                                    10 1
                                    10 2
                                    10 3
                                    10 4
                                                                                                                                  101
                                           0   100   200   300    400     500   600    700    800                                       0    100         200        300         400        500
                                                                 Layers                                                                                    Layers

Figure 4: The convergence of intermediate activations in TrellisNet (with kernel size 2) and weight-
tied transformers on different sequence lengths.


usually lead to a oscillatory behavior on the plots (Figure 4), with values fluctuating around the
actual fixed point (which we empirically verify can be found much more easily with Newton or
quasi-Newton methods).
In practice, due to limited computation, we usually set the number of layers to a predetermined
number (e.g., 60 layers) and rarely reach the inference depths analyzed in Figure 4. Moreover, in the
specific case of transformers, [1] stablizes the training of deep transformers (64-layer) on character-
level language modeling with the help of various strong auxiliary losses at intermediate layers. In
a certain sense, the addition of auxiliary losses have a similar effect as solving for equilibrium: we
want intermediate-level hidden units to be both close to the target and as stable as possible (without
drastic interlayer differences).


E    More Remarks on DEQ

Applicability of other deep techniques. While the DEQ approach does not preclude specific
architectural choices of fθ (which means techniques such as layer normalization [5] or weight
normalization [39] can work as is), it is not clear how certain regularizations such as auxiliary
losses [46, 8] could be applied on DEQ, since there are no more “layers”. For dropout [44], we
follow the practice of [8], which adapts the RNN variational dropout [22] scheme to feedforward
networks by applying the same mask at all levels. We empirically find that adding dropout makes the
quasi-Newton methods slower to converge (i.e., inference-time equilibria are easier to find without
the presence of noisy zeros). Since the weights of fθ (and thus its operator norm) are directly related
to the stability of root-finding, we observe that weight normalization [39] typically finds more stable
parameters and slows down the growth of forward/backward Broyden’s iterations (as described in
Figure 2).

Imbalances within minibatches. Not all sequences in a minibatch converge to the equilibrium
with the same number of iterations. However, with standard batched CUDA operations, the sequences
that converge faster essentially need to “wait” for the slower ones. Though we empirically find such
imbalance to be relatively small in scale, it could mean an inefficient GPU utilization at times.

Warmup of DEQ models with shallow nets. Instead of training the DEQ from scratch, empirically
we find that one can accelerate the DEQ training by pretraining a shallow weight-tied stack of fθ
(e.g., 2 layers), and using the resulting parameters to initialize the DEQ. In general, a shallow model
plateaus at much lower accuracy than corresponding DEQs or deeper weight-tied networks. However,
given the very small number of layers, a shallow model offers a memory- and computation-efficient
starting point for DEQ training.

Training DEQs with subsequences. On extremely long sequences (e.g., T > 1000), the forward-
pass fixed points can be challenging to solve accurately (especially at the start of the training)
even with the help of the root-finding methods. Therefore, in practice, we suggest breaking these
long sequences into a few subsequences when needed (recall that the forward pass can be any
black-box root-finder). Moreover, with the help of Theorem 1, such subsequence technique can
be used in the backward pass as well (where we solve for Eq. (11)). For instance, on a sequence


                                                                                                    15
z?1:T = z?1:(T /2)    z?(T /2):T :
                               

                      ∂`      ∂`      ∂z?(T /2):T     ∂`      ∂z?(T /2):T dz?1:(T /2)
                          = ?                     + ?                                                  (22)
                     ∂(·)  ∂z(T /2):T    ∂(·)      ∂z(T /2):T ∂z?1:(T /2)   d(·)
                                      | {z }                  | {z } | {z }
                                            (A)                      (B)         (C)

where terms (A) and (B) require one evaluation of fθ (z?(T /2):T ; [x(T /2):T , z?1:(T /2) ]) and term (C)
requires one evaluation of fθ (z?1:(T /2) ; x1:(T /2) ). Hence, the memory cost is equivalent to that of
applying fθ once on the entire z?1:T (but with the subsequences’ equilibrium likely easier to optimize).

F    Task Descriptions
We briefly introduce the three sequence prediction tasks/datasets that we employ to evaluate the DEQ
approach in Section 5.
Copy memory task. The copy memory task is a small but challenging synthetic stress test that has
been frequently used in prior work to test a sequence model’s memory retention ability [53, 4, 7].
In this task, each sequence x1:(T +20) is 1-dimensional and has length T + 20, with x1:10 randomly
selected from integers 1, 2, . . . , 8 (with repetition). The rest of the input elements are all filled with
zeros, except for the xT +10 = 9. The goal of this task is to produce y1:(T +20) such that y1:T +10 = 0
and yT +11:T +20 = x1:10 . In other words, a sequence model trained on this task is expected to “recall”
the first 10 elements of the sequence once it sees the delimiter xT +10 = 9, and copy them to the end
of the sequence. We generate 20K training samples and 2K testing samples. In prior works, [7] have
shown that RNNs generally struggle with the task, especially when T > 100, whereas feedforward
models tend to have better memory.

Penn Treebank. The Penn Treebank (PTB) corpus [31] is a commonly used dataset for character-
and word-level language modeling. When used for word-level language modeling, PTB contains about
888K words at training, with a vocabulary size of 10,000. As this is a comparatively small language
corpus (with punctuations and capitalization removed), prior work has shown that well-designed
regularizations are required for best results [34, 52].

WikiText-103. The training corpus of WikiText-103 (WT103) [35] is about 110 times larger than
PTB, with a vocabulary size over 260K. In general, this dataset is considered much more realistic than
many others because it contains many rare words and retains punctuation, numbers, and capitalization
from the original Wikipedia articles. WT103 is thus used to evaluate how well a sequence model
scales to long sequences from a large vocabulary. This dataset has been frequently used in recent
work with high-capacity sequence models [9, 8, 16, 6].




                                                    16
